

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Usage &mdash; kanapy 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modeling" href="method.html" />
    <link rel="prev" title="Applications" href="applications.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> kanapy
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="applications.html">Applications</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#kanapy-s-cli">Kanapy’s CLI</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-examples">Running examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#through-cli">Through CLI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#through-python-script">Through python script</a></li>
<li class="toctree-l3"><a class="reference internal" href="#visualize-the-packing-simulation">Visualize the packing simulation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#detailed-tutorial">Detailed tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-file-structure">Input file structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workflows-for-sphere-packing">Workflows for sphere packing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-cli-sphere">Using CLI - sphere</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-python-script-sphere">Using Python script - sphere</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#workflows-for-ellipsoid-packing">Workflows for ellipsoid packing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-cli-ellipsoid">Using CLI - ellipsoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-python-script-ellipsoid">Using Python script - ellipsoid</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="method.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="kanapy.html">Code documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">kanapy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Usage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h1>
<div class="section" id="kanapy-s-cli">
<h2>Kanapy’s CLI<a class="headerlink" href="#kanapy-s-cli" title="Permalink to this headline">¶</a></h2>
<p>The available commands in Kanapy’s CLI and its usage is described here. The <code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">kanapy</span> <span class="pre">--help</span></code> command
details this as shown:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that you are within the virtual environment created during the kanapy installation, as
this environment contains the installed kanapy and its required dependencies.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> conda activate myenv
<span class="gp">(myenv) $</span> kanapy --help
<span class="go">          Usage: kanapy [OPTIONS] COMMAND [ARGS]...</span>
<span class="go">          Options:</span>
<span class="go">            --help  Show this message and exit.</span>

<span class="go">          Commands:</span>
<span class="go">            abaqusoutput  Writes out the Abaqus (.inp) file for the generated RVE.</span>
<span class="go">            neperoutput   Writes out particle position and weights files required for...</span>
<span class="go">            outputstats   Writes out the particle- and grain diameter attributes for...</span>
<span class="go">            pack          Packs the particles into a simulation box.</span>
<span class="go">            statgenerate  Generates particle statistics based on the data provided in...</span>
<span class="go">            voxelize      Generates the RVE by assigning voxels to grains.</span>
</pre></div>
</div>
<p>The functionality and the arguments of each command listed above can be requested. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">(myenv) $</span> kanapy neperoutput --help
<span class="go">          Usage: kanapy neperoutput [OPTIONS]</span>

<span class="go">            Writes out particle position and weights files required for tessellation</span>
<span class="go">            in Neper.</span>

<span class="go">          Options:</span>
<span class="go">            --timestep TEXT  Time step for which Neper input files will be generated.</span>
<span class="go">            --help           Show this message and exit.</span>
</pre></div>
</div>
</div>
<div class="section" id="running-examples">
<h2>Running examples<a class="headerlink" href="#running-examples" title="Permalink to this headline">¶</a></h2>
<p>Two examples come bundled along with the kanapy package, they can be run either through the
Command Line Interface (CLI) or through python scripts.</p>
<div class="section" id="through-cli">
<h3>Through CLI<a class="headerlink" href="#through-cli" title="Permalink to this headline">¶</a></h3>
<p>To run the examples, navigate into the corresponding directory where the input file <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code>
is located, and execute the CLI commands sequentially as shown:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that you are within the virtual environment created during the kanapy installation, as
this environment contains the installed kanapy and its required dependencies.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> conda activate myenv
<span class="gp">(myenv) $</span> <span class="nb">cd</span> kanapy-master/examples/
<span class="gp">(myenv) $</span> <span class="nb">cd</span> sphere_packing/
<span class="gp">(myenv) $</span> kanapy statgenerate --filename stat_input.json
<span class="gp">(myenv) $</span> kanapy pack
<span class="gp">(myenv) $</span> kanapy voxelize --timestep <span class="m">750</span>
<span class="gp">(myenv) $</span> kanapy abaqusoutput
<span class="gp">(myenv) $</span> kanapy outputstats
<span class="gp">(myenv) $</span> kanapy neperoutput --timestep <span class="m">750</span>
</pre></div>
</div>
<p>For a detailed description of the commands used above, refer to: <a class="reference internal" href="#using-cli-sphere"><span class="std std-ref">Using CLI - sphere</span></a>.</p>
</div>
<div class="section" id="through-python-script">
<h3>Through python script<a class="headerlink" href="#through-python-script" title="Permalink to this headline">¶</a></h3>
<p>Navigate into the example directory and execute the python script as shown:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Make sure that you are within the virtual environment created during the kanapy installation, as
this environment contains the installed kanapy and its required dependencies.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> conda activate myenv
<span class="gp">(myenv) $</span> <span class="nb">cd</span> kanapy-master/examples/
<span class="gp">(myenv) $</span> <span class="nb">cd</span> sphere_packing/
<span class="gp">(myenv) $</span> python sphere_pack.py
</pre></div>
</div>
<p>For a detailed description of the kanapy modules used in the script <code class="docutils literal notranslate"><span class="pre">sphere_pack.py</span></code>, refer to: <a class="reference internal" href="#using-python-script-sphere"><span class="std std-ref">Using Python script - sphere</span></a>.</p>
</div>
<div class="section" id="visualize-the-packing-simulation">
<h3>Visualize the packing simulation<a class="headerlink" href="#visualize-the-packing-simulation" title="Permalink to this headline">¶</a></h3>
<p>You can view the data generated by the simulation (after the simulation
is complete or during the simulation) by launching OVITO and reading in
the dump files generated by kanapy from the <code class="docutils literal notranslate"><span class="pre">../sphere_packing/dump_files/</span></code> directory.
The dump file is generated at each timestep of the particle packing simulation. It contains
the timestep, the number of particles, the simulation box dimensions and the particle’s attributes
such as its ID, position (x, y, z), axes lengths (a, b, c) and orientation (Quaternion format - X, Y, Z, W).
The OVITO user interface when loaded, should look similar to this:</p>
<a class="reference internal image-reference" href="_images/UI.png"><img alt="_images/UI.png" src="_images/UI.png" style="width: 750px;" /></a>
<p>By default, OVITO loads the particles as spheres, this option can be changed to visualize ellipsoids.
The asphericalshapex, asphericalshapey, and asphericalshapez columns need to be mapped to
Aspherical Shape.X, Aspherical Shape.Y, and Aspherical Shape.Z properties of OVITO when
importing the dump file. Similarily, the orientationx, orientationy, orientationz, and
orientationw particle properties need to be mapped to the Orientation.X, Orientation.Y,
Orientation.Z, and Orientation.W. OVITO cannot set up this mapping automatically, you have
to do it manually by using the <code class="docutils literal notranslate"><span class="pre">Edit</span> <span class="pre">column</span> <span class="pre">mapping</span></code> button (at the bottom-right corner
of the GUI) in the file import panel after loading the dump files. The required assignment
and components are shown here:</p>
<a class="reference internal image-reference" href="_images/UI_options.png"><img alt="_images/UI_options.png" src="_images/UI_options.png" style="width: 750px;" /></a>
<p>For further viewing customizations refer to OVITO’s <a class="reference external" href="https://ovito.org/manual/">documentation</a>.</p>
</div>
</div>
<div class="section" id="detailed-tutorial">
<h2>Detailed tutorial<a class="headerlink" href="#detailed-tutorial" title="Permalink to this headline">¶</a></h2>
<p>A detailed description of the default examples that come packaged with kanapy is presented here.
The two examples <code class="docutils literal notranslate"><span class="pre">sphere_packing</span></code> and <code class="docutils literal notranslate"><span class="pre">ellipsoid_packing</span></code> depict the different workflows
that have to be setup for generating synthetic microstructures with equiaxed and elongated
grains. Both examples contain an input file wherein the user can specify
the statistical parameters required for the simulation. For a detailed understanding of the
general framework of packing simulations, please refer to: <a class="reference internal" href="method.html#modeling"><span class="std std-ref">Modeling</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>New examples must be created in a separate directory under the <code class="docutils literal notranslate"><span class="pre">kanapy-master/examples/</span></code>
directory structure. It allows the kanapy modules an easy access to the json and
dump files created during the simulation.</p></li>
<li><p>The json and dump files help in making the various kanapy modules independent
of one another during execution.</p></li>
<li><p>The input file must always be named as: <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> to be read by kanapy.</p></li>
</ol>
</div>
<div class="section" id="input-file-structure">
<h3>Input file structure<a class="headerlink" href="#input-file-structure" title="Permalink to this headline">¶</a></h3>
<p>An exemplary structure of the input file: <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> is shown below:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
  <span class="s2">&quot;Equivalent diameter&quot;</span>:
    <span class="o">{</span>
      <span class="s2">&quot;std&quot;</span>: <span class="m">0</span>.531055,
      <span class="s2">&quot;mean&quot;</span>: <span class="m">2</span>.76736,
      <span class="s2">&quot;cutoff_min&quot;</span>: <span class="m">4</span>.0,
      <span class="s2">&quot;cutoff_max&quot;</span>: <span class="m">20</span>.0
    <span class="o">}</span>,
  <span class="s2">&quot;Aspect ratio&quot;</span>:
    <span class="o">{</span>
      <span class="s2">&quot;mean&quot;</span>: <span class="m">1</span>.0
    <span class="o">}</span>,
  <span class="s2">&quot;Orientation&quot;</span>:
    <span class="o">{</span>
      <span class="s2">&quot;sigma&quot;</span>: <span class="m">28</span>.8774,
      <span class="s2">&quot;mean&quot;</span>: <span class="m">87</span>.4178
    <span class="o">}</span>,
  <span class="s2">&quot;RVE&quot;</span>:
    <span class="o">{</span>
      <span class="s2">&quot;side_length&quot;</span>: <span class="m">60</span>.9,
      <span class="s2">&quot;voxel_per_side&quot;</span>: <span class="m">40</span>
    <span class="o">}</span>,
  <span class="s2">&quot;Simulation&quot;</span>:
    <span class="o">{</span>
      <span class="s2">&quot;nsteps&quot;</span>: <span class="m">1000</span>,
      <span class="s2">&quot;periodicity&quot;</span>: <span class="s2">&quot;True&quot;</span>,
      <span class="s2">&quot;output_units&quot;</span>: <span class="s2">&quot;mm&quot;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>The input file is built in the JSON file format, with the following keywords: <code class="docutils literal notranslate"><span class="pre">Equivalent</span> <span class="pre">diameter,</span> <span class="pre">Aspect</span> <span class="pre">ratio,</span>
<span class="pre">Orientation,</span> <span class="pre">RVE,</span> <span class="pre">Simulation</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li><p>The keyword <code class="docutils literal notranslate"><span class="pre">Equivalent</span> <span class="pre">diameter</span></code> takes in four arguments to generate a
log-normal distribution for the particle’s equivalent diameter; they are the
<a class="reference external" href="https://en.wikipedia.org/wiki/Log-normal_distribution">Log-normal distribution’s</a> standard deviation and mean, and the minimum
and maximum cut-off values for the diameter. The values should correspond to <span class="math notranslate nohighlight">\(\mu m\)</span> scale.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Aspect</span> <span class="pre">ratio</span></code> takes only the mean value as input. If the resultant
microstructure contains equiaxed grains then this value should be set to <cite>1</cite>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Orientation</span></code> keyword represents the tilt angle of particles with
respect to the positive x-axis. Hence, to generate a distribution, it takes in
two arguments: the normal distribution’s mean and the standard deviation.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">RVE</span></code> keyword takes two inputs: the side length of the final RVE
required and the number of voxels per RVE side length.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Simulation</span></code> keyword takes in three inputs: The total number of time steps
, a boolean value for periodicity (True/False) and the required unit scale (<span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span>) for the output
ABAQUS .inp file.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>The user may choose not to use the built-in voxelization (meshing) routine
for meshing the final RVE. Nevertheless, a value for <cite>voxel_per_side</cite> has to be provided.</p></li>
<li><p>A good estimation for <cite>voxel_per_side</cite> value can be made by keeping the
following point in mind: The smallest dimension of the smallest ellipsoid/sphere
should contain at least 3 voxels.</p></li>
<li><p>The <cite>nsteps</cite> value determines the growth of the particle during the simulation.
At the start of the simulation, all particles are initialized with null volume.
At each time step, they grow in size by the value: diameter/nsteps. Therefore, the last
timestep would naturally contain particles in their actual size.</p></li>
<li><p>The input unit scale should be in <span class="math notranslate nohighlight">\(\mu m\)</span> and the user can choose between
<span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> as the unit scale in which output the
ABAQUS .inp file will be written.</p></li>
</ol>
</div>
</div>
<div class="section" id="workflows-for-sphere-packing">
<h3>Workflows for sphere packing<a class="headerlink" href="#workflows-for-sphere-packing" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates the workflow for generating synthetic microstructures with
equiaxed grains. The principle involved in generating such microstructures are described
in the sub-section <a class="reference internal" href="applications.html#microstructure-with-equiaxed-grains"><span class="std std-ref">Microstructure with equiaxed grains</span></a>. With respect to the final RVE mesh,
the user has the flexibility to choose between the in-built voxelization routine and external meshing softwares.</p>
<p>If external meshing is required, the positions and weights of the particles (spheres) after packing
can be written out to be post-processed. The positions and weights can be read by the Voronoi tessellation
and meshing software <a class="reference external" href="http://neper.sourceforge.net/">Neper</a> for generating tessellations and FEM mesh. For more details refer to Neper’s
<a class="reference external" href="https://ovito.org/manual/">documentation</a>.</p>
<p>If the in-built voxelization routine is prefered, then the <a class="reference internal" href="kanapy.html#module-kanapy.voxelization"><span class="std std-ref">Module voxelization</span></a> will generate
hexahedral element (C3D8) mesh that can be read by the commercial FEM software <a class="reference external" href="https://www.3ds.com/products-services/simulia/products/abaqus/">Abaqus</a>. The Abaqus .inp
file will be written out in either <span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> scale.</p>
<div class="section" id="using-cli-sphere">
<h4>Using CLI - sphere<a class="headerlink" href="#using-cli-sphere" title="Permalink to this headline">¶</a></h4>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> conda activate myenv
<span class="gp">(myenv) $</span> <span class="nb">cd</span> kanapy-master/examples/
<span class="gp">(myenv) $</span> <span class="nb">cd</span> sphere_packing/
<span class="gp">(myenv) $</span> kanapy statgenerate --filename stat_input.json
<span class="gp">(myenv) $</span> kanapy pack
<span class="gp">(myenv) $</span> kanapy voxelize --timestep <span class="m">750</span>
<span class="gp">(myenv) $</span> kanapy abaqusoutput
<span class="gp">(myenv) $</span> kanapy outputstats
<span class="gp">(myenv) $</span> kanapy neperoutput --timestep <span class="m">750</span>
</pre></div>
</div>
<p>After navigating to the directory where the input file <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> is located, kanapy’s CLI
command <code class="docutils literal notranslate"><span class="pre">statgenerate</span></code> is executed along with its argument (name of the input file). Next the <code class="docutils literal notranslate"><span class="pre">pack</span></code> command is
called to run the particle packing simulation. The <code class="docutils literal notranslate"><span class="pre">voxelize</span></code> command populates the simulation box with voxels
and assigns the voxels to the respective particles (Spheres). The argument required for the <code class="docutils literal notranslate"><span class="pre">voxelize</span></code> command
is the timestep of the packing simulation. The choice of the timestep is very important. It is suggested to choose
the time step at which the spheres are tightly packed and at which there is the least amount of overlap. The
remaining empty spaces will get assigned to the closest sphere when it is sent to the meshing. Please refer to
<a class="reference internal" href="applications.html#microstructure-with-equiaxed-grains"><span class="std std-ref">Microstructure with equiaxed grains</span></a> for more details. The <code class="docutils literal notranslate"><span class="pre">abaqusoutput</span></code> command is called to write out
the Abaqus (.inp) input file. The <code class="docutils literal notranslate"><span class="pre">outputstats</span></code> command is called for generating equivalent
diameter statistics for comparing input particles and output grains. In both these commands, the output will be written
out in either <span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> scale, depending on the user requirement specified in the input file. Finally,
the <code class="docutils literal notranslate"><span class="pre">neperoutput</span></code> command is called (Optional) to write out particle’s positions (<code class="docutils literal notranslate"><span class="pre">sphere_positions.txt</span></code>) and weights
(<code class="docutils literal notranslate"><span class="pre">sphere_weights.txt</span></code>) files that can be used by Neper.</p>
</div>
<div class="section" id="using-python-script-sphere">
<h4>Using Python script - sphere<a class="headerlink" href="#using-python-script-sphere" title="Permalink to this headline">¶</a></h4>
<p><strong>Imports</strong>: This example requires the following imports from the Python standard and kanapy modules.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">kanapy</span>
<span class="kn">from</span> <span class="nn">kanapy.input_output</span> <span class="kn">import</span> <span class="n">particleStatGenerator</span>
<span class="kn">from</span> <span class="nn">kanapy.input_output</span> <span class="kn">import</span> <span class="n">write_position_weights</span>
<span class="kn">from</span> <span class="nn">kanapy.packing</span> <span class="kn">import</span> <span class="n">packingRoutine</span>
</pre></div>
</div>
<p>The methods for generating particle distribution statistics and outputing particle
position- and weights are imported from the <code class="docutils literal notranslate"><span class="pre">input_output</span></code> module. The routine
for the actual particle packing simulation is imported from the <code class="docutils literal notranslate"><span class="pre">packing</span></code> module.</p>
<p><strong>Workflow</strong>: The complete process consists of 3 stages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Particle data generation.</p></li>
<li><p>Particle packing simulation.</p></li>
<li><p>Writing output files.</p></li>
</ul>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">inputFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;/stat_input.json&#39;</span>
    <span class="n">particleStatGenerator</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)</span>
    <span class="n">packingRoutine</span><span class="p">()</span>
    <span class="n">write_position_weights</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
    <span class="k">return</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>Individual stages can be run by commenting out the other stages but should be done sequentially.</p></li>
<li><p>The <a class="reference internal" href="kanapy.html#kanapy.input_output.particleStatGenerator" title="kanapy.input_output.particleStatGenerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.particleStatGenerator()</span></code></a> method requires the <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> as input.</p></li>
<li><p>The <a class="reference internal" href="kanapy.html#kanapy.input_output.write_position_weights" title="kanapy.input_output.write_position_weights"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_position_weights()</span></code></a> method requires the simulation timestep as input.
The choice of the timestep is very important. It is suggested to choose the time step at which the spheres
are tightly packed and at which there is the least amount of overlap. The remaining empty spaces will get assigned to
the closest sphere when it is sent to the tessellation and meshing routine. Please refer to
<a class="reference internal" href="applications.html#microstructure-with-equiaxed-grains"><span class="std std-ref">Microstructure with equiaxed grains</span></a> for more details.</p></li>
<li><p>The values of position and weights for Neper will be written in <span class="math notranslate nohighlight">\(\mu m\)</span> scale only.</p></li>
</ol>
</div>
<p>The data required for the packing simulation contained in the user-defined input file: <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> is read
by the method <a class="reference internal" href="kanapy.html#kanapy.input_output.particleStatGenerator" title="kanapy.input_output.particleStatGenerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.particleStatGenerator()</span></code></a>. It generates the necessary particle, RVE, and
the simulation attributes, and it writes it to json files. The method <a class="reference internal" href="kanapy.html#kanapy.packing.packingRoutine" title="kanapy.packing.packingRoutine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.packing.packingRoutine()</span></code></a>, when
called, looks for the json files generated by <a class="reference internal" href="kanapy.html#kanapy.input_output.particleStatGenerator" title="kanapy.input_output.particleStatGenerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.particleStatGenerator()</span></code></a>
and reads the files for extracting the information required for the packing simulation. At each time step of the
packing simulation, the <a class="reference internal" href="kanapy.html#kanapy.packing.particle_grow" title="kanapy.packing.particle_grow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.packing.particle_grow()</span></code></a> method will write out a dump file containing information
of particle positions and other attributes.</p>
<p>Finally, the <a class="reference internal" href="kanapy.html#kanapy.input_output.write_position_weights" title="kanapy.input_output.write_position_weights"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_position_weights()</span></code></a> method can be called
to write out the position and weights files required for further post-processing. This function takes the
specified timestep value as an input parameter and reads the corresponding, previously generated dump file.
By extracting the particle’s position and dimensions, it creates the <code class="docutils literal notranslate"><span class="pre">sphere_positions.txt</span></code> &amp;
<code class="docutils literal notranslate"><span class="pre">sphere_weights.txt</span></code> files.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For comparing the input and output statistics:</p>
<ol class="arabic simple">
<li><p>The json file <code class="docutils literal notranslate"><span class="pre">particle_data.json</span></code> in the directory <code class="docutils literal notranslate"><span class="pre">../json_files/</span></code> can be used to
read the particle’s equivalent diameter as input statistics.</p></li>
<li><p>After tessellation, Neper can be used to generate the equivalent diameter for output statistics.</p></li>
</ol>
</div>
<p>If the built-in voxelization is prefered, then the <a class="reference internal" href="kanapy.html#kanapy.voxelization.voxelizationRoutine" title="kanapy.voxelization.voxelizationRoutine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.voxelization.voxelizationRoutine()</span></code></a> method can be called
to generate the hexahedral mesh. This function also takes in the timestep value as an input parameter and reads the
corresponding, previously generated dump file. The <a class="reference internal" href="kanapy.html#kanapy.input_output.write_abaqus_inp" title="kanapy.input_output.write_abaqus_inp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_abaqus_inp()</span></code></a> method can be called to
write out the Abaqus (.inp) input file. The Abaqus (.inp) file will be written out in either <span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> scale,
depending on the user requirement specified in the input file. The workflow for this looks like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">kanapy.voxelization</span> <span class="kn">import</span> <span class="n">voxelizationRoutine</span>
<span class="kn">from</span> <span class="nn">kanapy.input_output</span> <span class="kn">import</span> <span class="n">write_abaqus_inp</span><span class="p">,</span> <span class="n">write_output_stat</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">inputFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;/stat_input.json&#39;</span>
    <span class="n">particleStatGenerator</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)</span>
    <span class="n">packingRoutine</span><span class="p">()</span>
    <span class="n">voxelizationRoutine</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
    <span class="n">write_abaqus_inp</span><span class="p">()</span>
    <span class="n">write_output_stat</span><span class="p">()</span>
    <span class="k">return</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For comparing the input and the output equivalent diameter statistics the method
<a class="reference internal" href="kanapy.html#kanapy.input_output.write_output_stat" title="kanapy.input_output.write_output_stat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_output_stat()</span></code></a> can be called. This function writes the diameter values
in either <span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> scale, depending on the user requirement specified in the input file.</p>
</div>
<p>Storing information in json &amp; dump files is effective in making the workflow stages independent of one another.
But the sequence of the workflow is important, for example: Running the packing routine before the statistics generation
is not advised as the packing routine would not have any input to work on. Both the json and the dump files are human readable,
and hence they help the user debug the code in case of simulation problems. As mentioned earlier, the dump files can
be read by the visualization software <a class="reference external" href="https://ovito.org/">OVITO</a>; this provides the user a visual aid to understand the physics behind packing.</p>
</div>
</div>
<div class="section" id="workflows-for-ellipsoid-packing">
<h3>Workflows for ellipsoid packing<a class="headerlink" href="#workflows-for-ellipsoid-packing" title="Permalink to this headline">¶</a></h3>
<p>This example demonstrates the workflow for generating synthetic microstructures with
elongated grains. The principle involved in generating such microstructures is described
in the sub-section <a class="reference internal" href="applications.html#microstructure-with-elongated-grains"><span class="std std-ref">Microstructure with elongated grains</span></a>. With respect to the final RVE mesh,
the built-in voxelization routine has to be used due to the inavailability of anisotropic tessellation techniques.
The <a class="reference internal" href="kanapy.html#module-kanapy.voxelization"><span class="std std-ref">Module voxelization</span></a> will generate a hexahedral element (C3D8) mesh that can be read by the commercial FEM software <a class="reference external" href="https://www.3ds.com/products-services/simulia/products/abaqus/">Abaqus</a>.</p>
<div class="section" id="using-cli-ellipsoid">
<h4>Using CLI - ellipsoid<a class="headerlink" href="#using-cli-ellipsoid" title="Permalink to this headline">¶</a></h4>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> conda activate myenv
<span class="gp">(myenv) $</span> <span class="nb">cd</span> kanapy-master/examples/
<span class="gp">(myenv) $</span> <span class="nb">cd</span> ellipsoid_packing/
<span class="gp">(myenv) $</span> kanapy statgenerate --filename stat_input.json
<span class="gp">(myenv) $</span> kanapy pack
<span class="gp">(myenv) $</span> kanapy voxelize --timestep <span class="m">750</span>
<span class="gp">(myenv) $</span> kanapy abaqusoutput
<span class="gp">(myenv) $</span> kanapy outputstats
</pre></div>
</div>
<p>The workflow is similar to the one described earlier for sphere packing. The only difference being, that the <code class="docutils literal notranslate"><span class="pre">neperoutput</span></code>
command is not applicable here. The <code class="docutils literal notranslate"><span class="pre">outputstats</span></code> command not only writes out the equivalent diameters, but also the
major and minor diameters of the ellipsoidal particles and grains.</p>
</div>
<div class="section" id="using-python-script-ellipsoid">
<h4>Using Python script - ellipsoid<a class="headerlink" href="#using-python-script-ellipsoid" title="Permalink to this headline">¶</a></h4>
<p><strong>Imports</strong>: This example requires the following methods to be imported from kanapy modules.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">kanapy</span>
<span class="kn">from</span> <span class="nn">kanapy.input_output</span> <span class="kn">import</span> <span class="n">particleStatGenerator</span>
<span class="kn">from</span> <span class="nn">kanapy.input_output</span> <span class="kn">import</span> <span class="n">write_abaqus_inp</span><span class="p">,</span> <span class="n">write_output_stat</span>
<span class="kn">from</span> <span class="nn">kanapy.packing</span> <span class="kn">import</span> <span class="n">packingRoutine</span>
<span class="kn">from</span> <span class="nn">kanapy.voxelization</span> <span class="kn">import</span> <span class="n">voxelizationRoutine</span>
</pre></div>
</div>
<p>The methods for generating particle distribution statistics and for outputing the Abaqus input file
are imported from the <code class="docutils literal notranslate"><span class="pre">input_output</span></code> module. The routine for the actual particle packing
simulation is imported from the <code class="docutils literal notranslate"><span class="pre">packing</span></code> module. And the routine for generating hexahedral mesh
is imported from the <code class="docutils literal notranslate"><span class="pre">voxelization</span></code> module.</p>
<p><strong>Workflow</strong>: The complete process consists of 4 stages:</p>
<blockquote>
<div><ul class="simple">
<li><p>Particle data generation.</p></li>
<li><p>Particle packing simulation.</p></li>
<li><p>RVE voxelization.</p></li>
<li><p>Writing output files.</p></li>
</ul>
</div></blockquote>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">inputFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;/stat_input.json&#39;</span>
    <span class="n">particleStatGenerator</span><span class="p">(</span><span class="n">inputFile</span><span class="p">)</span>
    <span class="n">packingRoutine</span><span class="p">()</span>
    <span class="n">voxelizationRoutine</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
    <span class="n">write_abaqus_inp</span><span class="p">()</span>
    <span class="n">write_output_stat</span><span class="p">()</span>
    <span class="k">return</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol class="arabic simple">
<li><p>As mentioned previously, individual stages can be run by commenting out the other stages but should be done sequentially.</p></li>
<li><p>The <a class="reference internal" href="kanapy.html#kanapy.input_output.particleStatGenerator" title="kanapy.input_output.particleStatGenerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.particleStatGenerator()</span></code></a> method requires the <code class="docutils literal notranslate"><span class="pre">stat_input.json</span></code> as input.</p></li>
<li><p>The <a class="reference internal" href="kanapy.html#kanapy.voxelization.voxelizationRoutine" title="kanapy.voxelization.voxelizationRoutine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.voxelization.voxelizationRoutine()</span></code></a> method requires the simulation timestep as input.
The choice of the timestep is very important. It is suggested to choose the time step at which the ellipsoids
are tightly packed and there is the least amount of overlap. The remaining empty spaces will get assigned to
the closest ellipsoid when it is sent to the voxelization (meshing) routine. Please refer to
<a class="reference internal" href="applications.html#microstructure-with-elongated-grains"><span class="std std-ref">Microstructure with elongated grains</span></a> for more details.</p></li>
<li><p>For comparing the input and output equivalent, major and minor diameter statistics, the method
<a class="reference internal" href="kanapy.html#kanapy.input_output.write_output_stat" title="kanapy.input_output.write_output_stat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_output_stat()</span></code></a> can be called. This function writes the diameter values
in either <span class="math notranslate nohighlight">\(mm\)</span> or <span class="math notranslate nohighlight">\(\mu m\)</span> scale, depending on the user requirement specified in the input file.</p></li>
</ol>
</div>
<p>The process of the methods <a class="reference internal" href="kanapy.html#kanapy.input_output.particleStatGenerator" title="kanapy.input_output.particleStatGenerator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.particleStatGenerator()</span></code></a> and <a class="reference internal" href="kanapy.html#kanapy.packing.packingRoutine" title="kanapy.packing.packingRoutine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.packing.packingRoutine()</span></code></a>
is similar to that described in <a class="reference internal" href="#using-python-script-ellipsoid"><span class="std std-ref">Using Python script - ellipsoid</span></a>. But for voxelization, the <a class="reference internal" href="kanapy.html#kanapy.voxelization.voxelizationRoutine" title="kanapy.voxelization.voxelizationRoutine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.voxelization.voxelizationRoutine()</span></code></a>
method is called to generate the hexahedral mesh. It takes in the timestep value as an input parameter and reads the corresponding,
previously generated dump file. By extracting the particle’s position and dimensions, it creates the final FEM mesh. Finally,
the <a class="reference internal" href="kanapy.html#kanapy.input_output.write_abaqus_inp" title="kanapy.input_output.write_abaqus_inp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kanapy.input_output.write_abaqus_inp()</span></code></a> method can be called to write out the Abaqus (.inp) input file.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="method.html" class="btn btn-neutral float-right" title="Modeling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="applications.html" class="btn btn-neutral float-left" title="Applications" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Mahesh R.G Prasad

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>