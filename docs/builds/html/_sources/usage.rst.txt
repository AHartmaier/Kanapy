.. highlight:: shell

======
Usage
======


Running examples
-----------------

Two examples come bundled along with the kanapy package. You can run 
them individually by navigating into the corresponding directories and executing 
them as shown:


.. note:: Make sure that you are within the virtual environment created during kanapy installation.
          As this environment contains the installed kanapy and its required dependencies.
          
          
.. code-block:: console

    $ conda activate myenv
    (myenv) $ cd kanapy-master/examples/
    (myenv) $ cd sphere_packing/
    (myenv) $ python sphere_pack.py  

You can view the data generated by the simulation (after the simulation
is complete or during the simulation) by launching OVITO and reading in 
the dump files generated by kanapy from the ``../sphere_packing/dump_files/`` directory. 
The UI should look similar to this:

.. image:: /figs/UI.png
    :width: 750px    

By default OVITO loads the particles as spheres, to change this option to ellipsoids. 
The asphericalshapex, asphericalshapey, and asphericalshapez columns need to be mapped to 
Aspherical Shape.X, Aspherical Shape.Y, and Aspherical Shape.Z properties of OVITO when 
importing the dump file. Similarily, the orientationx, orientationy, orientationz, and 
orientationw particle properties need to be mapped to the Orientation.X, Orientation.Y, 
Orientation.Z, and Orientation.W. OVITO cannot set up this mapping automatically, you have 
to do it manually by using the ``Edit column mapping`` button (at the bottom right corner 
of the GUI) in the file import panel after loading the dump files. The required assignment 
and components are shown here:

.. image:: /figs/UI_options.png
    :width: 750px    

For further viewing customization refer to OVITO's documentation_.

.. _documentation: https://ovito.org/manual/ 


Detailed tutorial
------------------

A detailed description of the default examples that come packaged with kanapy is presented here. 
The two examples ``sphere_packing`` and ``ellipsoid_packing`` depict the different workflows 
that has to be setup for generating synthetic microstructures with equiaxed and elongated 
grains respectively. Both the examples contain an input file wherein the user can specify 
the statistical parameters required for the simulation. For a detailed understanding of the 
general framework of packing simulations please refer to: :ref:`Modeling`.

.. note:: 1. New examples must be created in a separate directory under the ``kanapy-master/examples/`` 
             directory structure. It allows the kanapy modules an easy access to the json and 
             dump files created during the simulation.
          2. The json and dump files help in making the various kanapy modules independent 
             of one another during execution.
          3. The input file must always be named as: ``stat_input.txt`` to be read by kanapy. 

^^^^^^^^^^^^^^^^^^^^^
Input file structure
^^^^^^^^^^^^^^^^^^^^^
An exemplary structure of the input file: ``stat_input.txt`` is shown below:

.. code-block::

    @ Equivalent diameter
    std =
    mean = 
    cutoff_min = 
    cutoff_max = 

    @ Aspect ratio
    mean = 

    @ Orientation
    sigma = 
    mean = 

    @ RVE 
    side_length = 
    voxel_per_side =   

    @ Simulation
    nsteps = 
    periodicity =   
    
It is built with the following keywords: ``@ Equivalent diameter, @ Aspect ratio, 
@ Orientation, @ RVE, @ Simulation``. 

  - The keyword ``@ Equivalent diameter`` takes in four arguments to generate a 
    log-normal distribution for particle's equivalent diameter, they are the 
    `Log-normal distribution's`_ standard deviation and mean, and the minimum 
    and maximum cut-off values for the diameter. The values should correspond to :math:`\mu m` scale.
  - The ``@ Aspect ratio`` takes only the mean value as input. If the resultant 
    microstructure should contain equiaxed grains then this value should be set to `1`.
  - The ``@ Orientation`` keyword represents the tilt angle of particles with 
    respect to the positive x-axis. Hence, to generate a distribution it takes in 
    two arguments: the normal distribution's mean and the standard deviation. 
  - The ``@ RVE`` keyword takes two inputs: the side length of the final RVE 
    required and the number of voxels per RVE side length. 
  - The ``@ Simulation`` keyword takes in two inputs: The total number of time steps
    and a boolean value for periodicity (True/False).

.. note:: 1. The user may choose not to use the built-in voxelization (meshing) routine 
             for meshing the final RVE. Nevertheless, a value for `voxel_per_side` has to be provided.
          2. A good estimation for `voxel_per_side` value can be made by keeping the 
             following point in mind: The smallest dimension of the smallest ellipsoid/sphere 
             should contain atleast 3 voxels.
          3. The `nsteps` value determines the growth of the particle during the simulation. 
             At the start of the simulation all particles are initialized with null volume. 
             At each time step they grow in size by the value: diameter/nsteps. Theerefore, the last 
             timestep would naturally contain particles in their actual size. 

.. _Log-normal distribution's: https://en.wikipedia.org/wiki/Log-normal_distribution   
                   
^^^^^^^^^^^^^^^^^^
Example workflows
^^^^^^^^^^^^^^^^^^

"""""""""""""""
Sphere packing
"""""""""""""""

This example demonstrates the workflow for generating synthetic microstructures with
equiaxed grains. The principle involved in generating such microstructures are described
in the sub-section :ref:`Microstructure with equiaxed grains`. With respect to the final RVE mesh, 
the user has the flexibility to choose between the in-built voxelization routine and external meshing softwares.

If external meshing is required then the positions and weights of the particles (spheres) after packing 
can be written out to be post-processed. The positions and weights can be read by Voronoi tessellation 
and meshing software Neper_ for generating tessellations and FEM mesh. For more details refer to Neper's 
documentation_.

If the in-built voxelization routine is prefered, then the :ref:`Module voxelization` will generate
hexahedral element (C3D8) mesh that can be read by commercial FEM software Abaqus_. The Abaqus .inp 
file will be written out in :math:`mm` scale.

.. _Neper: http://neper.sourceforge.net/
.. _documentaion: http://neper.sourceforge.net/docs/neper.pdf
.. _Abaqus: https://www.3ds.com/products-services/simulia/products/abaqus/

**Imports**: This example requires the following imports from the python standard and kanapy modules.

.. code-block:: python

    import os 
    import sys
    
    import kanapy
    from kanapy.input_output import particleStatGenerator
    from kanapy.input_output import write_position_weights
    from kanapy.packing import packingRoutine    

The methods for generating particle distribution statistics and outputing particle 
position and weights are imported from the ``input_output`` module. The routine
for the actual particle packing simulation is imported from the ``packing`` module.

**Workflow**: The complete process consists of 3 stages: 

  - Particle data generation.
  - Particle packing simulation.
  - Writing output files.

.. code-block:: python

    def main():
        inputFile = os.getcwd() + '/stat_input.txt'
        particleStatGenerator(inputFile)
        packingRoutine()                                            
        write_position_weights(800)
        return

    if __name__ == '__main__':
        main()

.. note:: 1. Individual stages can be run by commenting out the other stages but should be done sequentially.
          2. The :meth:`src.kanapy.input_output.particleStatGenerator` method requires the ``stat_input.txt`` as input.
          3. The :meth:`src.kanapy.input_output.write_position_weights` method requires the simulation timestep as input.
             The choice of the timestep is very important. It is suggested to choose the time step at which the spheres
             are tightly packed and there is least amount of overlap. The remaining empty spaces will get assigned to 
             the closest sphere when it is sent to the tessellation and meshing routine. Please refer to 
             :ref:`Microstructure with equiaxed grains` for more details.   
          
The data required for packing simulation contained in the user defined input file: ``stat_input.txt`` is read 
by the method :meth:`src.kanapy.input_output.particleStatGenerator`. It generates the necessary particle, RVE and 
the simulation attributes and writes it to json files. The method :meth:`src.kanapy.packing.packingRoutine` when 
called looks for the json files generated by :meth:`src.kanapy.input_output.particleStatGenerator`
and reads the files for extracting information required for the packing simulation. At each time step of the 
packing simulation the :meth:`src.kanapy.packing.particle_grow` method will write out a dump file containing information
of particle positions and other attributes. 

Finally, the :meth:`src.kanapy.input_output.write_position_weights` method can be called 
to write out the position and weights files required for further post-processing. This function takes the
specified timestep value as an input parameter and reads the corresponding dump file generated previously. 
By extracting the particle's position and dimensions it creates the ``sphere_positions.txt`` & 
``sphere_weights.txt`` files.  

.. note:: For comparing the input and output statistics:  
        
            1. The json file ``particle_data.txt`` in the directory ``../json_files/`` can be used to 
               read the particle's equivalent diameter as input statistics.
            2. After tessellation,`Neper` can be used to generate the equivalent diameter for output statistics.
          
          
If the built-in voxelization is prefered then the :meth:`src.kanapy.voxelization.voxelizationRoutine` method can be called 
to generate the hexahedral mesh. This function also takes in the timestep value as an input parameter and reads the 
corresponding dump file generated previously. The :meth:`src.kanapy.input_output.write_abaqus_inp` method can be called to 
write out Abaqus (.inp) input file. The Abaqus .inp file will be written out in :math:`mm` scale. The workflow for this looks like:

.. code-block:: python
    
    from kanapy.voxelization import voxelizationRoutine
    from kanapy.input_output import write_abaqus_inp, write_output_stat
    
    def main():
        inputFile = os.getcwd() + '/stat_input.txt'
        particleStatGenerator(inputFile)
        packingRoutine()                                            
        voxelizationRoutine(800)
        write_abaqus_inp()
        write_output_stat()
        return

    if __name__ == '__main__':
        main()

.. note:: For comparing the input and output equivalent diameter statistics the method 
          :meth:`src.kanapy.input_output.write_output_stat` can be called.                     
                  
Storing information in json & dump files is effective in making the workflow stages independent of one another. 
But the sequence of the workflow is important, for example: Running the packing routine before the statistics generation 
is not advised as the packing routine would not have any input to work on. Both the json and dump files are human readable 
and hence they help the user debug the code in case of simulation problems. As mentioned earlier, the dump files can
be read by visualization software OVITO_, this provides the user a visual aid to understand the physics behind packing. 

.. _OVITO: https://ovito.org/             


""""""""""""""""""
Ellipsoid packing
""""""""""""""""""

This example demonstrates the workflow for generating synthetic microstructures with
elongated grains. The principle involved in generating such microstructures are described
in the sub-section :ref:`Microstructure with elongated grains`. With respect to the final RVE mesh, 
the built-in voxelization routine has to be used due to the inavailability of anisotropic tessellation techniques.
The :ref:`Module voxelization` will generate hexahedral element (C3D8) mesh that can be read by commercial FEM software Abaqus_.

.. _Abaqus: https://www.3ds.com/products-services/simulia/products/abaqus/


**Imports**: This example requires the following methods to be imported from kanapy modules.

.. code-block:: python

    import os 
    import sys
    
    import kanapy
    from kanapy.input_output import particleStatGenerator
    from kanapy.input_output import write_abaqus_inp, write_output_stat
    from kanapy.packing import packingRoutine
    from kanapy.voxelization import voxelizationRoutine    

The methods for generating particle distribution statistics and outputing Abaqus input file
are imported from the ``input_output`` module. The routine for the actual particle packing 
simulation is imported from the ``packing`` module. And the routine for generating hexahedral mesh
is imported from ``voxelization`` module.      


**Workflow**: The complete process consists of 4 stages: 

  - Particle data generation.
  - Particle packing simulation.
  - RVE voxelization.
  - Writing output files.

.. code-block:: python

    def main():
        inputFile = os.getcwd() + '/stat_input.txt'
        particleStatGenerator(inputFile)
        packingRoutine()    
        voxelizationRoutine(800)   
        write_abaqus_inp()  
        write_output_stat()                                           
        return

    if __name__ == '__main__':
        main()

.. note:: 1. As mentioned previously, individual stages can be run by commenting out the other stages but should be done sequentially.
          2. The :meth:`src.kanapy.input_output.particleStatGenerator` method requires the ``stat_input.txt`` as input.
          3. The :meth:`src.kanapy.voxelization.voxelizationRoutine` method requires the simulation timestep as input.
             The choice of the timestep is very important. It is suggested to choose the time step at which the ellipsoids
             are tightly packed and there is least amount of overlap. The remaining empty spaces will get assigned to 
             the closest ellipsoid when it is sent to the voxelization (meshing) routine. Please refer to 
             :ref:`Microstructure with elongated grains` for more details.  
          4. For comparing the input and output equivalent, major and minor diameter statistics the method 
             :meth:`src.kanapy.input_output.write_output_stat` can be called.               

The process of the methods :meth:`src.kanapy.input_output.particleStatGenerator` and :meth:`src.kanapy.packing.packingRoutine`
is similar to that described in :ref:`Sphere packing`. But for voxelization the :meth:`src.kanapy.voxelization.voxelizationRoutine` 
method is called to generate the hexahedral mesh. It takes in the timestep value as an input parameter and reads the corresponding 
dump file generated previously. By extracting the particle's position and dimensions it creates the final FEM mesh. Finally, 
the :meth:`src.kanapy.input_output.write_abaqus_inp` method can be called to write out Abaqus (.inp) input file. 
