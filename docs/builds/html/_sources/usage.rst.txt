.. highlight:: shell

======
Usage
======

Kanapy's CLI
------------ 

The available commands in Kanapy's CLI and its usage is described here. The ``$ kanapy --help`` command 
details this as shown:

.. note:: Make sure that you are within the virtual environment created during the kanapy installation, as 
          this environment contains the installed kanapy and its required dependencies.
          
.. code-block:: console

    $ conda activate myenv
    (myenv) $ kanapy --help
              Usage: kanapy [OPTIONS] COMMAND [ARGS]...
              Options:
                --help  Show this message and exit.

              Commands:
                abaqusoutput  Writes out the Abaqus (.inp) file for the generated RVE.
                neperoutput   Writes out particle position and weights files required for...
                outputstats   Writes out the particle- and grain diameter attributes for...
                pack          Packs the particles into a simulation box.
                statgenerate  Generates particle statistics based on the data provided in...
                voxelize      Generates the RVE by assigning voxels to grains.

The functionality and the arguments of each command listed above can be requested. For example:

.. code-block:: console

    (myenv) $ kanapy neperoutput --help
              Usage: kanapy neperoutput [OPTIONS]

                Writes out particle position and weights files required for tessellation
                in Neper.

              Options:
                --timestep TEXT  Time step for which Neper input files will be generated.
                --help           Show this message and exit.
                

Running examples
-----------------

Two examples come bundled along with the kanapy package, they can be run either through the 
Command Line Interface (CLI) or through python scripts. 

^^^^^^^^^^^^
Through CLI
^^^^^^^^^^^^
To run the examples, navigate into the corresponding directory where the input file ``stat_input.json``
is located, and execute the CLI commands sequentially as shown:

.. note:: Make sure that you are within the virtual environment created during the kanapy installation, as 
          this environment contains the installed kanapy and its required dependencies.
          
.. code-block:: console

    $ conda activate myenv
    (myenv) $ cd kanapy-master/examples/
    (myenv) $ cd sphere_packing/
    (myenv) $ kanapy statgenerate --filename stat_input.json
    (myenv) $ kanapy pack
    (myenv) $ kanapy voxelize --timestep 750
    (myenv) $ kanapy abaqusoutput
    (myenv) $ kanapy outputstats
    (myenv) $ kanapy neperoutput --timestep 750

For a detailed description of the commands used above, refer to: :ref:`Using CLI - sphere`.

^^^^^^^^^^^^^^^^^^^^^
Through python script
^^^^^^^^^^^^^^^^^^^^^    
Navigate into the example directory and execute the python script as shown: 

.. note:: Make sure that you are within the virtual environment created during the kanapy installation, as 
          this environment contains the installed kanapy and its required dependencies.
                    
.. code-block:: console

    $ conda activate myenv
    (myenv) $ cd kanapy-master/examples/
    (myenv) $ cd sphere_packing/
    (myenv) $ python sphere_pack.py 

For a detailed description of the kanapy modules used in the script ``sphere_pack.py``, refer to: :ref:`Using Python script - sphere`.

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Visualize the packing simulation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 

You can view the data generated by the simulation (after the simulation
is complete or during the simulation) by launching OVITO and reading in 
the dump files generated by kanapy from the ``../sphere_packing/dump_files/`` directory. 
The dump file is generated at each timestep of the particle packing simulation. It contains 
the timestep, the number of particles, the simulation box dimensions and the particle's attributes 
such as its ID, position (x, y, z), axes lengths (a, b, c) and orientation (Quaternion format - X, Y, Z, W).
The OVITO user interface when loaded, should look similar to this:

.. image:: /figs/UI.png
    :width: 750px    

By default, OVITO loads the particles as spheres, this option can be changed to visualize ellipsoids. 
The asphericalshapex, asphericalshapey, and asphericalshapez columns need to be mapped to 
Aspherical Shape.X, Aspherical Shape.Y, and Aspherical Shape.Z properties of OVITO when 
importing the dump file. Similarily, the orientationx, orientationy, orientationz, and 
orientationw particle properties need to be mapped to the Orientation.X, Orientation.Y, 
Orientation.Z, and Orientation.W. OVITO cannot set up this mapping automatically, you have 
to do it manually by using the ``Edit column mapping`` button (at the bottom-right corner 
of the GUI) in the file import panel after loading the dump files. The required assignment 
and components are shown here:

.. image:: /figs/UI_options.png
    :width: 750px    

For further viewing customizations refer to OVITO's documentation_.

.. _documentation: https://ovito.org/manual/ 


Detailed tutorial
------------------           
                
A detailed description of the default examples that come packaged with kanapy is presented here. 
The two examples ``sphere_packing`` and ``ellipsoid_packing`` depict the different workflows 
that have to be setup for generating synthetic microstructures with equiaxed and elongated 
grains. Both examples contain an input file wherein the user can specify 
the statistical parameters required for the simulation. For a detailed understanding of the 
general framework of packing simulations, please refer to: :ref:`Modeling`.

.. note:: 1. New examples must be created in a separate directory under the ``kanapy-master/examples/`` 
             directory structure. It allows the kanapy modules an easy access to the json and 
             dump files created during the simulation.
          2. The json and dump files help in making the various kanapy modules independent 
             of one another during execution.
          3. The input file must always be named as: ``stat_input.json`` to be read by kanapy. 

^^^^^^^^^^^^^^^^^^^^^
Input file structure
^^^^^^^^^^^^^^^^^^^^^
An exemplary structure of the input file: ``stat_input.json`` is shown below:

.. code-block::

    {
      "Equivalent diameter": 
        {
          "std": 0.531055,
          "mean": 2.76736,
          "cutoff_min": 4.0,
          "cutoff_max": 20.0
        },
      "Aspect ratio": 
        {
          "mean": 1.0        
        },           
      "Orientation":
        {
          "sigma": 28.8774,
          "mean": 87.4178    
        },
      "RVE": 
        {
          "side_length": 60.9,
          "voxel_per_side": 40
        },
      "Simulation":
        {
          "nsteps": 1000,
          "periodicity": "True",                                         
          "output_units": "mm"         
        }
    }
    
The input file is built in the JSON file format, with the following keywords: ``Equivalent diameter, Aspect ratio, 
Orientation, RVE, Simulation``. 

  - The keyword ``Equivalent diameter`` takes in four arguments to generate a 
    log-normal distribution for the particle's equivalent diameter; they are the 
    `Log-normal distribution's`_ standard deviation and mean, and the minimum 
    and maximum cut-off values for the diameter. The values should correspond to :math:`\mu m` scale.
  - The ``Aspect ratio`` takes only the mean value as input. If the resultant 
    microstructure contains equiaxed grains then this value should be set to `1`.
  - The ``Orientation`` keyword represents the tilt angle of particles with 
    respect to the positive x-axis. Hence, to generate a distribution, it takes in 
    two arguments: the normal distribution's mean and the standard deviation. 
  - The ``RVE`` keyword takes two inputs: the side length of the final RVE 
    required and the number of voxels per RVE side length. 
  - The ``Simulation`` keyword takes in three inputs: The total number of time steps
    , a boolean value for periodicity (True/False) and the required unit scale (:math:`mm` or :math:`\mu m`) for the output 
    ABAQUS .inp file.

.. note:: 1. The user may choose not to use the built-in voxelization (meshing) routine 
             for meshing the final RVE. Nevertheless, a value for `voxel_per_side` has to be provided.
          2. A good estimation for `voxel_per_side` value can be made by keeping the 
             following point in mind: The smallest dimension of the smallest ellipsoid/sphere 
             should contain at least 3 voxels.
          3. The `nsteps` value determines the growth of the particle during the simulation. 
             At the start of the simulation, all particles are initialized with null volume. 
             At each time step, they grow in size by the value: diameter/nsteps. Therefore, the last 
             timestep would naturally contain particles in their actual size. 
          4. The input unit scale should be in :math:`\mu m` and the user can choose between 
             :math:`mm` or :math:`\mu m` as the unit scale in which output the 
             ABAQUS .inp file will be written. 

.. _Log-normal distribution's: https://en.wikipedia.org/wiki/Log-normal_distribution   


^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Workflows for sphere packing 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This example demonstrates the workflow for generating synthetic microstructures with
equiaxed grains. The principle involved in generating such microstructures are described
in the sub-section :ref:`Microstructure with equiaxed grains`. With respect to the final RVE mesh, 
the user has the flexibility to choose between the in-built voxelization routine and external meshing softwares.

If external meshing is required, the positions and weights of the particles (spheres) after packing 
can be written out to be post-processed. The positions and weights can be read by the Voronoi tessellation 
and meshing software Neper_ for generating tessellations and FEM mesh. For more details refer to Neper's 
documentation_.

If the in-built voxelization routine is prefered, then the :ref:`Module voxelization` will generate
hexahedral element (C3D8) mesh that can be read by the commercial FEM software Abaqus_. The Abaqus .inp 
file will be written out in either :math:`mm` or :math:`\mu m` scale.

.. _Neper: http://neper.sourceforge.net/
.. _documentaion: http://neper.sourceforge.net/docs/neper.pdf
.. _Abaqus: https://www.3ds.com/products-services/simulia/products/abaqus/

""""""""""""""""""
Using CLI - sphere
""""""""""""""""""
.. code-block:: console

    $ conda activate myenv
    (myenv) $ cd kanapy-master/examples/
    (myenv) $ cd sphere_packing/
    (myenv) $ kanapy statgenerate --filename stat_input.json
    (myenv) $ kanapy pack
    (myenv) $ kanapy voxelize --timestep 750
    (myenv) $ kanapy abaqusoutput
    (myenv) $ kanapy outputstats
    (myenv) $ kanapy neperoutput --timestep 750

After navigating to the directory where the input file ``stat_input.json`` is located, kanapy's CLI 
command ``statgenerate`` is executed along with its argument (name of the input file). Next the ``pack`` command is
called to run the particle packing simulation. The ``voxelize`` command populates the simulation box with voxels 
and assigns the voxels to the respective particles (Spheres). The argument required for the ``voxelize`` command 
is the timestep of the packing simulation. The choice of the timestep is very important. It is suggested to choose 
the time step at which the spheres are tightly packed and at which there is the least amount of overlap. The 
remaining empty spaces will get assigned to the closest sphere when it is sent to the meshing. Please refer to 
:ref:`Microstructure with equiaxed grains` for more details. The ``abaqusoutput`` command is called to write out 
the Abaqus (.inp) input file. The ``outputstats`` command is called for generating equivalent 
diameter statistics for comparing input particles and output grains. In both these commands, the output will be written 
out in either :math:`mm` or :math:`\mu m` scale, depending on the user requirement specified in the input file. Finally,
the ``neperoutput`` command is called (Optional) to write out particle's positions (``sphere_positions.txt``) and weights 
(``sphere_weights.txt``) files that can be used by Neper.
                                   
""""""""""""""""""""""""""""
Using Python script - sphere
""""""""""""""""""""""""""""

**Imports**: This example requires the following imports from the Python standard and kanapy modules.

.. code-block:: python

    import os 
    import sys
    
    import kanapy
    from kanapy.input_output import particleStatGenerator
    from kanapy.input_output import write_position_weights
    from kanapy.packing import packingRoutine    

The methods for generating particle distribution statistics and outputing particle 
position- and weights are imported from the ``input_output`` module. The routine
for the actual particle packing simulation is imported from the ``packing`` module.

**Workflow**: The complete process consists of 3 stages: 

  - Particle data generation.
  - Particle packing simulation.
  - Writing output files.

.. code-block:: python

    def main():
        inputFile = os.getcwd() + '/stat_input.json'
        particleStatGenerator(inputFile)
        packingRoutine()                                            
        write_position_weights(750)
        return

    if __name__ == '__main__':
        main()

.. note:: 1. Individual stages can be run by commenting out the other stages but should be done sequentially.
          2. The :meth:`kanapy.input_output.particleStatGenerator` method requires the ``stat_input.json`` as input.
          3. The :meth:`kanapy.input_output.write_position_weights` method requires the simulation timestep as input.
             The choice of the timestep is very important. It is suggested to choose the time step at which the spheres
             are tightly packed and at which there is the least amount of overlap. The remaining empty spaces will get assigned to 
             the closest sphere when it is sent to the tessellation and meshing routine. Please refer to 
             :ref:`Microstructure with equiaxed grains` for more details.   
          4. The values of position and weights for Neper will be written in :math:`\mu m` scale only.
          
The data required for the packing simulation contained in the user-defined input file: ``stat_input.json`` is read 
by the method :meth:`kanapy.input_output.particleStatGenerator`. It generates the necessary particle, RVE, and 
the simulation attributes, and it writes it to json files. The method :meth:`kanapy.packing.packingRoutine`, when 
called, looks for the json files generated by :meth:`kanapy.input_output.particleStatGenerator`
and reads the files for extracting the information required for the packing simulation. At each time step of the 
packing simulation, the :meth:`kanapy.packing.particle_grow` method will write out a dump file containing information
of particle positions and other attributes. 

Finally, the :meth:`kanapy.input_output.write_position_weights` method can be called 
to write out the position and weights files required for further post-processing. This function takes the
specified timestep value as an input parameter and reads the corresponding, previously generated dump file. 
By extracting the particle's position and dimensions, it creates the ``sphere_positions.txt`` & 
``sphere_weights.txt`` files.  

.. note:: For comparing the input and output statistics:  
        
            1. The json file ``particle_data.json`` in the directory ``../json_files/`` can be used to 
               read the particle's equivalent diameter as input statistics.
            2. After tessellation, Neper can be used to generate the equivalent diameter for output statistics.
          
          
If the built-in voxelization is prefered, then the :meth:`kanapy.voxelization.voxelizationRoutine` method can be called 
to generate the hexahedral mesh. This function also takes in the timestep value as an input parameter and reads the 
corresponding, previously generated dump file. The :meth:`kanapy.input_output.write_abaqus_inp` method can be called to 
write out the Abaqus (.inp) input file. The Abaqus (.inp) file will be written out in either :math:`mm` or :math:`\mu m` scale, 
depending on the user requirement specified in the input file. The workflow for this looks like:

.. code-block:: python
    
    from kanapy.voxelization import voxelizationRoutine
    from kanapy.input_output import write_abaqus_inp, write_output_stat
    
    def main():
        inputFile = os.getcwd() + '/stat_input.json'
        particleStatGenerator(inputFile)
        packingRoutine()                                            
        voxelizationRoutine(750)
        write_abaqus_inp()
        write_output_stat()
        return

    if __name__ == '__main__':
        main()

.. note:: For comparing the input and the output equivalent diameter statistics the method 
          :meth:`kanapy.input_output.write_output_stat` can be called. This function writes the diameter values
          in either :math:`mm` or :math:`\mu m` scale, depending on the user requirement specified in the input file.               
                  
Storing information in json & dump files is effective in making the workflow stages independent of one another. 
But the sequence of the workflow is important, for example: Running the packing routine before the statistics generation 
is not advised as the packing routine would not have any input to work on. Both the json and the dump files are human readable, 
and hence they help the user debug the code in case of simulation problems. As mentioned earlier, the dump files can
be read by the visualization software OVITO_; this provides the user a visual aid to understand the physics behind packing. 

.. _OVITO: https://ovito.org/             


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Workflows for ellipsoid packing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This example demonstrates the workflow for generating synthetic microstructures with
elongated grains. The principle involved in generating such microstructures is described
in the sub-section :ref:`Microstructure with elongated grains`. With respect to the final RVE mesh, 
the built-in voxelization routine has to be used due to the inavailability of anisotropic tessellation techniques.
The :ref:`Module voxelization` will generate a hexahedral element (C3D8) mesh that can be read by the commercial FEM software Abaqus_.

.. _Abaqus: https://www.3ds.com/products-services/simulia/products/abaqus/

"""""""""""""""""""""
Using CLI - ellipsoid
"""""""""""""""""""""

.. code-block:: console

    $ conda activate myenv
    (myenv) $ cd kanapy-master/examples/
    (myenv) $ cd ellipsoid_packing/
    (myenv) $ kanapy statgenerate --filename stat_input.json
    (myenv) $ kanapy pack
    (myenv) $ kanapy voxelize --timestep 750
    (myenv) $ kanapy abaqusoutput
    (myenv) $ kanapy outputstats

The workflow is similar to the one described earlier for sphere packing. The only difference being, that the ``neperoutput``
command is not applicable here. The ``outputstats`` command not only writes out the equivalent diameters, but also the 
major and minor diameters of the ellipsoidal particles and grains.
    
"""""""""""""""""""""""""""""""
Using Python script - ellipsoid
"""""""""""""""""""""""""""""""
    
**Imports**: This example requires the following methods to be imported from kanapy modules.

.. code-block:: python

    import os 
    import sys
    
    import kanapy
    from kanapy.input_output import particleStatGenerator
    from kanapy.input_output import write_abaqus_inp, write_output_stat
    from kanapy.packing import packingRoutine
    from kanapy.voxelization import voxelizationRoutine    

The methods for generating particle distribution statistics and for outputing the Abaqus input file
are imported from the ``input_output`` module. The routine for the actual particle packing 
simulation is imported from the ``packing`` module. And the routine for generating hexahedral mesh
is imported from the ``voxelization`` module.      


**Workflow**: The complete process consists of 4 stages: 

  - Particle data generation.
  - Particle packing simulation.
  - RVE voxelization.
  - Writing output files.

.. code-block:: python

    def main():
        inputFile = os.getcwd() + '/stat_input.json'
        particleStatGenerator(inputFile)
        packingRoutine()    
        voxelizationRoutine(750)   
        write_abaqus_inp()  
        write_output_stat()                                           
        return

    if __name__ == '__main__':
        main()

.. note:: 1. As mentioned previously, individual stages can be run by commenting out the other stages but should be done sequentially.
          2. The :meth:`kanapy.input_output.particleStatGenerator` method requires the ``stat_input.json`` as input.
          3. The :meth:`kanapy.voxelization.voxelizationRoutine` method requires the simulation timestep as input.
             The choice of the timestep is very important. It is suggested to choose the time step at which the ellipsoids
             are tightly packed and there is the least amount of overlap. The remaining empty spaces will get assigned to 
             the closest ellipsoid when it is sent to the voxelization (meshing) routine. Please refer to 
             :ref:`Microstructure with elongated grains` for more details.  
          4. For comparing the input and output equivalent, major and minor diameter statistics, the method 
             :meth:`kanapy.input_output.write_output_stat` can be called. This function writes the diameter values
             in either :math:`mm` or :math:`\mu m` scale, depending on the user requirement specified in the input file.            

The process of the methods :meth:`kanapy.input_output.particleStatGenerator` and :meth:`kanapy.packing.packingRoutine`
is similar to that described in :ref:`Using Python script - ellipsoid`. But for voxelization, the :meth:`kanapy.voxelization.voxelizationRoutine` 
method is called to generate the hexahedral mesh. It takes in the timestep value as an input parameter and reads the corresponding, 
previously generated dump file. By extracting the particle's position and dimensions, it creates the final FEM mesh. Finally, 
the :meth:`kanapy.input_output.write_abaqus_inp` method can be called to write out the Abaqus (.inp) input file. 
